### 함수 포인터

- 함수명 앞에 \*만 붙여주면된다
  - 자료형(\*함수 포인터 이름)(인자 목록)
- 함수 포인터를 사용하는 이유
  - 메모리의 크기 및 위치가 결정 되는 시점은 컴파일 타임 또는 런타임 시점
  - 컴파일 타임 시점에 결정은 정적 바인딩, 런타임 시전의 결정은 동적 바인딩
  - **함수 포인터의 사용은 프로그램의 유연한 확장성을 제공**

### 구조체

- 하나 이상의 서로 다른 종류의 변수들을 묶어서 새로운 **데이터 타입**을 정의하는 것
- 사용자 커스텀 데이터 타입
- 구조체를 사용하는 이유
  - 연관된 변수들을 하나로 묶어 관리함으로 데이터 관리에 유용
  - 데이터 양(변수의 개수)가 많아질 수록 효율적
- 구조체 기본 형태

```c
struct student{
	char name[10];
	int age;
	int height;
}
```

- struct 키워드는 구조체 타입을 의미
- student는 내가 만든 구조체 이름
- name, age, height는 구조체 멤버
- [구조체 변수명].[구조체 멤버]
  - .을 통해서 접근하며 이를 직접접근 이라고한다
- 평가문제
  - 구조체를 활용해 값을 입력하고 출력
  ```c
  #include <stdio.h>

  struct Object {
      char name[50];
      int height;
      int weight;
  };

  int main() {
      struct Object item = {"hello", 19, 38};
      printf("아이템의 이름 : %s\n높이 : %d\n무게 : %d\n", item.name, item.height, item.weight);

      return 0;
  }

  ```

### 공용체

- 공용체도 사용자 정의 자료형
- 구조체와 차이점은 메모리 공간을 공유한다는 점

### 열거형

- enumeration의 약자로 enum
- 데이터들을 열거한 집합
- 컴파일러는 열거형 멤버들을 정수형 상수로 취급

### 메모리 구조

- 코드영역 : 실행할 명령어들이 순서대로 쌓임, CPU가 이 영역에서 명령어들을 하나씩 처리
- 스택영역 : 모든 원소들의 삽입, 삭제를 한쪽 방향에서만 수행하도록 하는 선형 자료구조

### 객체 지향 프로그래밍 방식

- 구조적 프로그래밍 방식은, 순차적, 하향식, 폭포수 방식인데 이와 대조되는 개념
- 객체 지향 프로그래밍 방식
  - 기능 단위가 객체
  - 고객의 요구사항이 변경되어도 기능 단위로 수정하기 때문에 수정이 용이
  ### 추상화
  - 대상에서 특징만을 뽑아낸 것
