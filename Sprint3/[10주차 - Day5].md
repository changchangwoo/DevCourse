### 클래스의 기본

- 클래스는 사용자 정의 데이터 타입
- 구조체와 비슷하며, 내가 새로 정의한 데이터 타입이기 때문에 추상적인 데이터 타입이라고 함
- 사물의 특성을 정리하여 필드와 메소드로 표현하는 과정이 **‘추상화’**
- 추상화된 결과를 하나의 클래스에 포함시키고 스스로 보호하는것이 **‘캡슐화’**

```jsx
class 클래스 이름
{
생성자, 소멸자, 변수, 메소드 등 선언
}
```

- 클래스 선언 형식
    - 접근 지정자
    
    | 접근지정자 | 의미 |
    | --- | --- |
    | public | 누구나 접근 가능 |
    | protected | 상속 관계에 있을 때 상속 받은 자식 클래스에서 접근 가능 |
    | internal | 같은 프로젝트 내 모든 클래스 접근 가능 |
    | private | 내 클래스 내부에서만 접근 가능 |
- 클래스를 통해 선언한 변수를 ‘**객체’**라고한다

### 생성자

- 모든 변수는 선언 되면 값을 초기화 해야한다
- 객체도 본질적으로 변수이므로 선언되면 초기화해야한다
- 객체 생성 시 초기화 전용 메소드를 제공하는데 이것이 바로 **생성자(constructor)**

### 상속성

- 프로젝트 관점에서 상속 개념
    - A 프로젝트 (종료), B 프로젝트 (신규)
    - B 프로젝트는 A 프로젝트를 상속 받고, 추가 기능만 구현하면 된다

### 오버로딩/오버라이딩

- 다형성
    - 함수의 이름이 같더라도 전달인자 타입이나 개수에 따라 구분
    - 객체 지향에서는 오버로딩과 오버라이딩 기법이 있다
- 오버로딩
    - ‘과적하다’,’적재하다’
    - 같은 이름의 함수에 같은 개수의 전달인자가 서로 다른 타입으로 존재하는 경우
    
    ```jsx
    int Plust(int a, int b){
    }
    char Plust(char a, char b){
    }
    dobule Plust(dobule a, dobule b){
    }
    ```
    
    - 같은 이름의 함수이지만 매개 변수에 따라 서로 다르게 동작한다
- 오버라이딩
    - 무언가에 올라타서 기존의 것을 덮어 버린다는 개념
    - **‘상속’의** 개념 기반

### 인터페이스

- 메소드의 목록만을 가지고 있는 명세, 사용자 정의 타입
- 메소드의 목록만 선언하고 구현은 하지 않는다
- 사용하는 이유
    - 본체가 정의되지 않는 추상 메소드만 갖는다
    - 기존의 기능을 추가하거나 수정하기보다는 동일한 개념의 기능을 새로히 구현하는 기능
    - **공동 작업시 표준을 정한다**
- **인터페이스에서 기능을 명세, 자식클래스에서 상속 후 구현**

### 람다

- 익명 메소드
    - 메소드를 미리 정의하지 않고 사용할 때 정의
    - 코드가 간결, 코딩 오버헤드를 줄일 수 있다
    - 내용이 복잡하면 안되며 람다식에서 주로 사용
- 람다식 표현
    - 델리게이트 본체를 람다식으로 표현
    - 델리게이트와 인수의 개수 및 타입은 일치해야 한다
    - (인수) ⇒ 표현식 또는 명령문
    - **(x, y) ⇒ x + y 람다식은 “x와 y가 x+y가 된다”**
    - **Delegate키워드는 사라지며 람다식을 의미한 ⇒ 기호로 대체**
    
    ```jsx
    Delegate(int x, int y) {retrun x + y}
    (x, y) => x + y
    ```